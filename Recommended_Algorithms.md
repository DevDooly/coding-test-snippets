# 코딩 테스트 추천 알고리즘 목록

이 문서는 코딩 테스트에서 자주 사용되며, 반드시 숙지해야 할 주요 알고리즘들을 정리한 목록입니다.

---

## 1. 그래프 (Graph)

-   **DFS (깊이 우선 탐색)**: 그래프의 모든 정점을 방문하는 가장 기본적인 방법 중 하나입니다. (현재 예제: [GraphSearch.java](./algorithms/graph/GraphSearch.java))
-   **BFS (너비 우선 탐색)**: 최단 경로를 찾는 문제에 널리 사용됩니다. (현재 예제: [GraphSearch.java](./algorithms/graph/GraphSearch.java))
-   **다익스트라 (Dijkstra)**: 가중치가 있는 그래프에서 한 정점으로부터 다른 모든 정점까지의 최단 경로를 찾는 알고리즘입니다. (PriorityQueue를 사용하면 효율적으로 구현 가능)
-   **플로이드-워셜 (Floyd-Warshall)**: 모든 정점에서 모든 다른 정점까지의 최단 경로를 찾는 알고리즘입니다. (DP 기반)
-   **위상 정렬 (Topological Sort)**: 순서가 정해져 있는 작업들을 순서대로 나열할 때 사용됩니다. (DAG: 방향 비순환 그래프에서만 가능)
-   **최소 신장 트리 (MST - Minimum Spanning Tree)**: 그래프의 모든 정점을 연결하되, 간선의 가중치 합을 최소로 만드는 알고리즘입니다. (크루스칼, 프림 알고리즘)

## 2. 동적 계획법 (Dynamic Programming - DP)

-   복잡한 문제를 작은 하위 문제로 나누어 해결하는 방법입니다.
-   **메모이제이션(Memoization)**과 **타뷸레이션(Tabulation)** 두 가지 접근 방식이 있습니다.
-   **유형**:
    -   **배낭 문제 (Knapsack Problem)**: 제한된 용량의 배낭에 최대 가치를 담는 문제.
    -   **최장 증가 부분 수열 (LIS - Longest Increasing Subsequence)**: 주어진 수열에서 가장 긴 증가하는 부분 수열을 찾는 문제.
    -   **최장 공통 부분 수열 (LCS - Longest Common Subsequence)**: 두 수열에서 공통적으로 나타나는 가장 긴 부분 수열을 찾는 문제.
    -   기타 점화식을 세워 해결할 수 있는 다양한 문제들.

## 3. 탐색 (Search) & 정렬 (Sort)

-   **이진 탐색 (Binary Search)**: 정렬된 배열에서 특정 값을 빠르게 찾는 알고리즘입니다. (시간 복잡도: O(log N))
-   **파라메트릭 서치 (Parametric Search)**: 최적화 문제를 결정 문제로 바꾸어 이진 탐색으로 해결하는 기법입니다.
-   **퀵 정렬 (Quick Sort)**, **병합 정렬 (Merge Sort)**: 효율적인 정렬 알고리즘의 내부 동작 원리를 이해하는 것이 중요합니다. (시간 복잡도: O(N log N))

## 4. 그리디 (Greedy)

-   각 단계에서 가장 최선이라고 생각되는 선택을 하여 최종적인 해답에 도달하는 방법입니다.
-   선택이 다음 단계에 영향을 주지 않고, 각 단계의 최적해가 전체의 최적해로 이어지는 경우에만 유효합니다.
-   **예시**: 회의실 배정, 동전 거스름돈 문제 등.

## 5. 문자열 (String)

-   **KMP 알고리즘**: 특정 문자열 안에서 다른 문자열이 몇 번이나 등장하는지 빠르게 찾는 알고리즘입니다.
-   **트라이 (Trie)**: 문자열을 효율적으로 저장하고 검색하기 위한 트리 자료구조입니다. (자동 완성 등에 활용)
-   **해싱 (Hashing)**: 문자열을 숫자로 변환하여 비교나 탐색을 빠르게 수행하는 기법입니다. (라빈-카프 알고리즘)

---

이 목록에 있는 알고리즘들의 기본 개념과 구현 방법을 익히면 대부분의 코딩 테스트 문제에 효과적으로 대응할 수 있습니다.
